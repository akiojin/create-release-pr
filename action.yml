name: Create Release PR
description: Create a release PR from source branch to target branch with version bump and CHANGELOG

inputs:
  source-branch:
    description: Source branch to create release from
    required: false
    default: develop
  target-branch:
    description: Target branch for the release PR
    required: false
    default: main
  github-token:
    description: GitHub token for creating PR
    required: true

outputs:
  version:
    description: New version number
    value: ${{ steps.version.outputs.version }}
  pr-number:
    description: Created PR number
    value: ${{ steps.create-pr.outputs.pr-number }}
  pr-url:
    description: Created PR URL
    value: ${{ steps.create-pr.outputs.pr-url }}

runs:
  using: composite
  steps:
    - name: Setup Git
      shell: bash
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"

    - name: Fetch all branches and tags
      shell: bash
      run: |
        git fetch --tags
        git fetch origin ${{ inputs.target-branch }}

    - name: Determine version bump
      id: version
      shell: bash
      run: |
        # SemVer regex pattern (strict)
        SEMVER_REGEX="^([0-9]+)\.([0-9]+)\.([0-9]+)(-([0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*))?(\+([0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*))?$"

        # Get last tag that matches v*.*.* pattern (semantic versioning)
        # Filter tags to only those starting with 'v' followed by a digit
        LAST_TAG=$(git tag --list 'v[0-9]*' --sort=-v:refname | head -n1)

        if [ -z "$LAST_TAG" ]; then
          echo "::error::No semantic version tags found (expected format: v*.*.*, e.g., v1.0.0)"
          echo "::error::Please create an initial tag with: git tag v0.0.0 && git push origin v0.0.0"
          exit 1
        fi

        echo "Last tag: $LAST_TAG"

        # Parse current version (remove 'v' prefix)
        CURRENT_VERSION=${LAST_TAG#v}

        # Validate SemVer format
        if [[ ! "$CURRENT_VERSION" =~ $SEMVER_REGEX ]]; then
          echo "::error::Tag '$LAST_TAG' is not a valid semantic version"
          echo "::error::Expected format: vMAJOR.MINOR.PATCH (e.g., v1.0.0, v2.1.3)"
          exit 1
        fi

        # Extract major, minor, patch
        MAJOR="${BASH_REMATCH[1]}"
        MINOR="${BASH_REMATCH[2]}"
        PATCH="${BASH_REMATCH[3]}"

        echo "Current version: $MAJOR.$MINOR.$PATCH"

        # IMPORTANT: Analyze commits between target branch and current HEAD
        # This ensures we only count NEW commits that will be included in this release,
        # not commits that were already released in previous versions.
        # Using origin/target-branch..HEAD instead of tag..HEAD to avoid including
        # commits from different branch paths.
        TARGET_BRANCH="origin/${{ inputs.target-branch }}"
        COMMITS=$(git log ${TARGET_BRANCH}..HEAD --oneline 2>/dev/null)

        if [ -z "$COMMITS" ]; then
          echo "::error::No commits found between ${TARGET_BRANCH} and HEAD"
          echo "::error::Nothing to release"
          exit 1
        fi

        echo "Commits to be released (${TARGET_BRANCH}..HEAD):"
        echo "$COMMITS" | head -20

        # Check for breaking changes (! suffix or BREAKING CHANGE in body)
        if echo "$COMMITS" | grep -qE "^[a-f0-9]+ (feat|fix)(\(.+\))?!:"; then
          BUMP="major"
          MAJOR=$((MAJOR + 1))
          MINOR=0
          PATCH=0
        elif echo "$COMMITS" | grep -qE "^[a-f0-9]+ feat(\(.+\))?:"; then
          BUMP="minor"
          MINOR=$((MINOR + 1))
          PATCH=0
        else
          BUMP="patch"
          PATCH=$((PATCH + 1))
        fi

        NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"

        # Validate new version is also SemVer (sanity check)
        if [[ ! "$NEW_VERSION" =~ $SEMVER_REGEX ]]; then
          echo "::error::Generated version '$NEW_VERSION' is not valid SemVer (this is a bug)"
          exit 1
        fi

        echo "Version bump: $BUMP ($CURRENT_VERSION -> $NEW_VERSION)"
        echo "version=$NEW_VERSION" >> "$GITHUB_OUTPUT"
        echo "bump=$BUMP" >> "$GITHUB_OUTPUT"

    - name: Merge target branch into source
      shell: bash
      run: |
        # Merge target branch (e.g., main) into source branch (e.g., develop)
        # This ensures CHANGELOG and version files are up-to-date with the latest release
        echo "Merging ${{ inputs.target-branch }} into current branch to sync release artifacts..."
        git merge origin/${{ inputs.target-branch }} --no-edit -X ours || {
          echo "::warning::Merge had conflicts, resolved using 'ours' strategy"
        }

    - name: Create release branch
      id: branch
      shell: bash
      run: |
        TIMESTAMP=$(date +%Y%m%d-%H%M%S)
        BRANCH_NAME="release/${TIMESTAMP}"
        git checkout -b "$BRANCH_NAME"
        echo "branch=$BRANCH_NAME" >> "$GITHUB_OUTPUT"

    - name: Install git-cliff
      shell: bash
      run: |
        if ! command -v git-cliff &> /dev/null; then
          cargo install git-cliff --locked || {
            # Fallback: download pre-built binary
            curl -sSL https://github.com/orhun/git-cliff/releases/latest/download/git-cliff-x86_64-unknown-linux-gnu.tar.gz | tar xz
            sudo mv git-cliff /usr/local/bin/
          }
        fi

    - name: Update CHANGELOG
      shell: bash
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        if [ -f cliff.toml ]; then
          git-cliff --tag "v${VERSION}" -o CHANGELOG.md
        else
          # Fallback: simple changelog generation
          echo "# Changelog" > CHANGELOG.md
          echo "" >> CHANGELOG.md
          echo "## v${VERSION}" >> CHANGELOG.md
          echo "" >> CHANGELOG.md
          git log $(git tag --list 'v[0-9]*' --sort=-v:refname | head -n1)..HEAD --pretty=format:"- %s" >> CHANGELOG.md
          echo "" >> CHANGELOG.md
        fi

    - name: Update Cargo.toml version (Rust)
      shell: bash
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        if [ -f Cargo.toml ]; then
          echo "Updating Cargo.toml to version ${VERSION}"
          sed -i "s/^version = \"[^\"]*\"/version = \"${VERSION}\"/" Cargo.toml
        fi

    - name: Update package.json version (Node.js/npm)
      shell: bash
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        if [ -f package.json ]; then
          echo "Updating package.json to version ${VERSION}"
          if command -v jq &> /dev/null; then
            jq ".version = \"${VERSION}\"" package.json > package.json.tmp && mv package.json.tmp package.json
          else
            sed -i "s/\"version\": \"[^\"]*\"/\"version\": \"${VERSION}\"/" package.json
          fi
        fi

    - name: Update pyproject.toml version (Python)
      shell: bash
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        if [ -f pyproject.toml ]; then
          echo "Updating pyproject.toml to version ${VERSION}"
          # Handle both [project] and [tool.poetry] sections
          sed -i "s/^version = \"[^\"]*\"/version = \"${VERSION}\"/" pyproject.toml
        fi

    - name: Update setup.py version (Python legacy)
      shell: bash
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        if [ -f setup.py ]; then
          echo "Updating setup.py to version ${VERSION}"
          sed -i "s/version=['\"][^'\"]*['\"]/version='${VERSION}'/" setup.py
        fi

    - name: Update composer.json version (PHP)
      shell: bash
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        if [ -f composer.json ]; then
          echo "Updating composer.json to version ${VERSION}"
          if command -v jq &> /dev/null; then
            jq ".version = \"${VERSION}\"" composer.json > composer.json.tmp && mv composer.json.tmp composer.json
          else
            sed -i "s/\"version\": \"[^\"]*\"/\"version\": \"${VERSION}\"/" composer.json
          fi
        fi

    - name: Update pubspec.yaml version (Dart/Flutter)
      shell: bash
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        if [ -f pubspec.yaml ]; then
          echo "Updating pubspec.yaml to version ${VERSION}"
          sed -i "s/^version: .*/version: ${VERSION}/" pubspec.yaml
        fi

    - name: Update version.rb (Ruby)
      shell: bash
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        # Find and update version.rb files
        for file in $(find . -name "version.rb" -type f 2>/dev/null | head -5); do
          echo "Updating ${file} to version ${VERSION}"
          sed -i "s/VERSION = ['\"][^'\"]*['\"]/VERSION = '${VERSION}'/" "$file"
        done

    - name: Update gemspec version (Ruby)
      shell: bash
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        for file in *.gemspec; do
          if [ -f "$file" ]; then
            echo "Updating ${file} to version ${VERSION}"
            sed -i "s/\.version\s*=\s*['\"][^'\"]*['\"]/.version = '${VERSION}'/" "$file"
          fi
        done

    - name: Update pom.xml version (Java/Maven)
      shell: bash
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        if [ -f pom.xml ]; then
          echo "Updating pom.xml to version ${VERSION}"
          # Update only the project version, not dependency versions
          sed -i "0,/<version>[^<]*<\/version>/s/<version>[^<]*<\/version>/<version>${VERSION}<\/version>/" pom.xml
        fi

    - name: Update build.gradle version (Gradle)
      shell: bash
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        if [ -f build.gradle ]; then
          echo "Updating build.gradle to version ${VERSION}"
          sed -i "s/version = ['\"][^'\"]*['\"]/version = '${VERSION}'/" build.gradle
        fi
        if [ -f build.gradle.kts ]; then
          echo "Updating build.gradle.kts to version ${VERSION}"
          sed -i "s/version = \"[^\"]*\"/version = \"${VERSION}\"/" build.gradle.kts
        fi

    - name: Update Package.swift version (Swift)
      shell: bash
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        if [ -f Package.swift ]; then
          echo "Updating Package.swift to version ${VERSION}"
          # Update version in package definition if present
          sed -i "s/version: \"[^\"]*\"/version: \"${VERSION}\"/" Package.swift
        fi

    - name: Update .csproj version (.NET/C#)
      shell: bash
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        # Update Directory.Build.props if exists (central version management)
        if [ -f Directory.Build.props ]; then
          echo "Updating Directory.Build.props to version ${VERSION}"
          sed -i "s/<Version>[^<]*<\/Version>/<Version>${VERSION}<\/Version>/" Directory.Build.props
          sed -i "s/<PackageVersion>[^<]*<\/PackageVersion>/<PackageVersion>${VERSION}<\/PackageVersion>/" Directory.Build.props
        fi
        # Update individual .csproj files
        for file in *.csproj; do
          if [ -f "$file" ]; then
            echo "Updating ${file} to version ${VERSION}"
            sed -i "s/<Version>[^<]*<\/Version>/<Version>${VERSION}<\/Version>/" "$file"
            sed -i "s/<PackageVersion>[^<]*<\/PackageVersion>/<PackageVersion>${VERSION}<\/PackageVersion>/" "$file"
          fi
        done

    - name: Update Chart.yaml version (Helm)
      shell: bash
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        if [ -f Chart.yaml ]; then
          echo "Updating Chart.yaml to version ${VERSION}"
          sed -i "s/^version: .*/version: ${VERSION}/" Chart.yaml
          sed -i "s/^appVersion: .*/appVersion: \"${VERSION}\"/" Chart.yaml
        fi

    - name: Commit and push changes
      shell: bash
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        BRANCH="${{ steps.branch.outputs.branch }}"

        git add -A
        git commit -m "chore(release): v${VERSION}

        - Update version to ${VERSION}
        - Update CHANGELOG.md"

        git push origin "$BRANCH"

    - name: Create Pull Request
      id: create-pr
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github-token }}
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        BRANCH="${{ steps.branch.outputs.branch }}"
        TARGET="${{ inputs.target-branch }}"

        PR_URL=$(gh pr create \
          --base "$TARGET" \
          --head "$BRANCH" \
          --title "chore(release): v${VERSION}" \
          --body "## Release v${VERSION}

        This PR was automatically created by the release workflow.

        ### Changes
        See CHANGELOG.md for details.

        ### Checklist
        - [ ] Version bumped correctly
        - [ ] CHANGELOG updated
        - [ ] All CI checks pass")

        PR_NUMBER=$(echo "$PR_URL" | grep -oE '[0-9]+$')

        echo "pr-url=$PR_URL" >> "$GITHUB_OUTPUT"
        echo "pr-number=$PR_NUMBER" >> "$GITHUB_OUTPUT"
        echo "Created PR #$PR_NUMBER: $PR_URL"
