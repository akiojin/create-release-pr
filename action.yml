name: Create Release PR
description: Create a release PR from source branch to target branch with version bump and CHANGELOG

inputs:
  source-branch:
    description: Source branch to create release from
    required: false
    default: develop
  target-branch:
    description: Target branch for the release PR
    required: false
    default: main
  github-token:
    description: GitHub token for creating PR
    required: true

outputs:
  version:
    description: New version number
    value: ${{ steps.version.outputs.version }}
  pr-number:
    description: Created PR number
    value: ${{ steps.create-pr.outputs.pr-number }}
  pr-url:
    description: Created PR URL
    value: ${{ steps.create-pr.outputs.pr-url }}

runs:
  using: composite
  steps:
    - name: Setup Git
      shell: bash
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"

    - name: Fetch all branches and tags
      shell: bash
      run: |
        git fetch --tags
        git fetch origin ${{ inputs.target-branch }}

    - name: Merge target branch into source
      shell: bash
      run: |
        echo "Merging ${{ inputs.target-branch }} into current branch to sync release artifacts..."
        git merge origin/${{ inputs.target-branch }} --no-edit -X ours || {
          echo "::warning::Merge had conflicts, resolved using 'ours' strategy"
        }

    - name: Determine version bump
      id: version
      shell: bash
      run: |
        SEMVER_REGEX="^([0-9]+)\.([0-9]+)\.([0-9]+)(-([0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*))?(\+([0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*))?$"

        LAST_TAG=$(git tag --list 'v[0-9]*' --sort=-v:refname | head -n1)

        if [ -z "$LAST_TAG" ]; then
          echo "::error::No semantic version tags found"
          exit 1
        fi

        echo "Last tag: $LAST_TAG"

        CURRENT_VERSION=${LAST_TAG#v}

        if [[ ! "$CURRENT_VERSION" =~ $SEMVER_REGEX ]]; then
          echo "::error::Tag '$LAST_TAG' is not a valid semantic version"
          exit 1
        fi

        MAJOR="${BASH_REMATCH[1]}"
        MINOR="${BASH_REMATCH[2]}"
        PATCH="${BASH_REMATCH[3]}"

        echo "Current version: $MAJOR.$MINOR.$PATCH"

        # Get the timestamp of the last tag (Unix epoch)
        # This handles squash merge history by only counting commits made AFTER the release
        LAST_TAG_DATE=$(git log -1 --format=%cI "$LAST_TAG" 2>/dev/null)
        echo "Last tag date: $LAST_TAG_DATE"

        # Get commits made AFTER the last release date
        # This excludes commits that were part of previous releases but appear
        # in main..develop due to squash merge breaking git ancestry
        COMMITS=$(git log --after="$LAST_TAG_DATE" \
          --no-merges \
          --oneline \
          HEAD 2>/dev/null | grep -vE "^[a-f0-9]+ chore(\(.+\))?:" || echo "")

        if [ -z "$COMMITS" ]; then
          # Check if there's actually a diff between branches
          DIFF_FILES=$(git diff --name-only origin/${{ inputs.target-branch }}..HEAD 2>/dev/null | head -5)
          if [ -z "$DIFF_FILES" ]; then
            echo "::error::No changes found since $LAST_TAG"
            exit 1
          fi
          echo "No feature commits found but files differ. Using patch bump."
          BUMP="patch"
          PATCH=$((PATCH + 1))
        else
          echo "Commits for version calculation (after $LAST_TAG_DATE):"
          echo "$COMMITS" | head -20

          if echo "$COMMITS" | grep -qE "^[a-f0-9]+ (feat|fix)(\(.+\))?!:"; then
            BUMP="major"
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
          elif echo "$COMMITS" | grep -qE "^[a-f0-9]+ feat(\(.+\))?:"; then
            BUMP="minor"
            MINOR=$((MINOR + 1))
            PATCH=0
          else
            BUMP="patch"
            PATCH=$((PATCH + 1))
          fi
        fi

        NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"

        echo "Version bump: $BUMP ($CURRENT_VERSION -> $NEW_VERSION)"
        echo "version=$NEW_VERSION" >> "$GITHUB_OUTPUT"
        echo "bump=$BUMP" >> "$GITHUB_OUTPUT"

    - name: Create release branch
      id: branch
      shell: bash
      run: |
        TIMESTAMP=$(date +%Y%m%d-%H%M%S)
        BRANCH_NAME="release/${TIMESTAMP}"
        git checkout -b "$BRANCH_NAME"
        echo "branch=$BRANCH_NAME" >> "$GITHUB_OUTPUT"

    - name: Install git-cliff
      shell: bash
      run: |
        if ! command -v git-cliff &> /dev/null; then
          cargo install git-cliff --locked || {
            curl -sSL https://github.com/orhun/git-cliff/releases/latest/download/git-cliff-x86_64-unknown-linux-gnu.tar.gz | tar xz
            sudo mv git-cliff /usr/local/bin/
          }
        fi

    - name: Update CHANGELOG
      shell: bash
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        if [ -f cliff.toml ]; then
          git-cliff --tag "v${VERSION}" -o CHANGELOG.md
        else
          echo "# Changelog" > CHANGELOG.md
          echo "" >> CHANGELOG.md
          echo "## v${VERSION}" >> CHANGELOG.md
          echo "" >> CHANGELOG.md
          git log $(git tag --list 'v[0-9]*' --sort=-v:refname | head -n1)..HEAD --pretty=format:"- %s" >> CHANGELOG.md
          echo "" >> CHANGELOG.md
        fi

    - name: Update Cargo.toml version (Rust)
      shell: bash
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        if [ -f Cargo.toml ]; then
          echo "Updating Cargo.toml to version ${VERSION}"
          sed -i "s/^version = \"[^\"]*\"/version = \"${VERSION}\"/" Cargo.toml
        fi

    - name: Update package.json version (Node.js/npm)
      shell: bash
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        if [ -f package.json ]; then
          echo "Updating package.json to version ${VERSION}"
          if command -v jq &> /dev/null; then
            jq ".version = \"${VERSION}\"" package.json > package.json.tmp && mv package.json.tmp package.json
          else
            sed -i "s/\"version\": \"[^\"]*\"/\"version\": \"${VERSION}\"/" package.json
          fi
        fi

    - name: Commit and push changes
      shell: bash
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        BRANCH="${{ steps.branch.outputs.branch }}"

        git add -A
        git commit -m "chore(release): v${VERSION}

        - Update version to ${VERSION}
        - Update CHANGELOG.md"

        git push origin "$BRANCH"

    - name: Create Pull Request with merge commit auto-merge
      id: create-pr
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github-token }}
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        BRANCH="${{ steps.branch.outputs.branch }}"
        TARGET="${{ inputs.target-branch }}"

        PR_URL=$(gh pr create \
          --base "$TARGET" \
          --head "$BRANCH" \
          --title "chore(release): v${VERSION}" \
          --body "## Release v${VERSION}

        This PR was automatically created by the release workflow.

        ### Changes
        See CHANGELOG.md for details.

        ### Checklist
        - [ ] Version bumped correctly
        - [ ] CHANGELOG updated
        - [ ] All CI checks pass")

        PR_NUMBER=$(echo "$PR_URL" | grep -oE '[0-9]+$')

        echo "pr-url=$PR_URL" >> "$GITHUB_OUTPUT"
        echo "pr-number=$PR_NUMBER" >> "$GITHUB_OUTPUT"
        echo "Created PR #$PR_NUMBER: $PR_URL"

        # Enable auto-merge with MERGE COMMIT (not squash!)
        # This preserves git ancestry for correct version calculation in future releases
        echo "Enabling auto-merge with merge commit strategy..."
        gh pr merge "$PR_URL" --auto --merge || {
          echo "::warning::Could not enable auto-merge. PR may need manual merge with merge commit."
        }
